[1,["b4oEY6dohLDpCEzvdQYK4Y"],["_effectAsset"],[["cc.Material",["_name","_techniqueData"],1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,3],[1,0,1,2,4]],[[[[0,"label",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[0]],[[[1,"label",[{"hash":3021642206,"record":null,"name":"label|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\n  in vec4 v_color;\n  #if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n#if USE_SHADOW\nuniform SHADOW_ARGS {\n  vec4 i_shadowColor;\n  vec2 i_shadowOffset;\n};\n#endif\n#if USE_OUTLINE\nuniform OUTLINE_ARGS {\n  vec4 i_outlineColor;\n  vec2 i_outlineWidth;\n};\n  #if USE_OUTLINE_SHADOW\nuniform OUTLINE_SHADOW_ARGS {\n  vec4 i_olShadowColor;\n  vec2 i_olShadowOffset;\n};\n  #endif\n#endif\n#if USE_GRADIENT\nuniform GRADIENT_ARGS {\n  vec4 i_color2;\n  vec4 i_color3;\n  float i_gRot;\n};\n#endif\n#if USE_GLOW\n  uniform GLOW_ARGS {\n  vec4 i_glowColor;\n  vec2 i_glowWidth;\n  float i_glowDepth;\n};\n#endif\n#if USE_FLOW_LIGHT\nuniform FLOW_LIGHT_ARGS {\n  vec4 i_flColor;\n  float i_flTime;\n  float i_flRot;\n  float i_flWidth;\n};\n#endif\n  uniform UARGS {\n    vec4 i_color1;\n    vec2 i_resolution;\n  };\n  const float PI = 3.1415;\n  const int accuracy = 32;\n  float getA(vec2 p) {\n  float a = 0.0001;\n#if USE_ARC\n    float r = -p.y+6.0;\n    float deg = p.x*0.7;\n    vec2 tp = vec2(\n        r*sin(deg)/4.5+0.5,\n        r*cos(deg)-5.4\n    );\n    a += texture2D(texture, tp).a;\n#else\n    vec2 tp = vec2(p.x+.5, .5-p.y);\n    a += step(abs(p.x), .5)*step(abs(p.y), .5)*texture2D(texture, tp).a;\n#endif\n    return a;\n  }\n  vec4 transCol(vec4 c1, vec4 c2) {\n    float k = (1.-c1.a)*c2.a/(c1.a+c2.a);\n    vec4 c = vec4(.0);\n    c.rgb = mix(c1.rgb, c2.rgb, k);\n    c.a = c1.a+k*c2.a;\n    return c;\n  }\n  void main () {\n    float dw = .0;\n  #if USE_SHADOW\n  dw += abs(i_shadowOffset.x);\n  #endif\n  #if USE_OUTLINE\n    dw += abs(i_outlineWidth.x*2.);\n  #if USE_OUTLINE_SHADOW\n    dw += abs(i_olShadowOffset.x);\n  #endif\n  #endif\n  #if USE_GLOW\n    dw += abs(i_glowWidth.x*2.);\n  #endif\n    float scale = 1.+dw;\n    vec2 uv = vec2(v_uv0.x-.5, .5-v_uv0.y)*scale;\n  #if USE_SHADOW\n    uv -= i_shadowOffset*0.5;\n  #endif\n  #if USE_OUTLINE\n  #if USE_OUTLINE_SHADOW\n    vec2 olsuv = vec2(i_olShadowOffset.x+sign(i_olShadowOffset.x)*i_outlineWidth.x, i_olShadowOffset.y+sign(i_olShadowOffset.y)*i_outlineWidth.y);\n    uv -= olsuv*0.5;\n  #endif\n  #endif\n  float a = getA(uv);\n  vec4 color = vec4(.0);\n  #if USE_GRADIENT == 3\n    float ratio = mix(uv.y,uv.x,i_gRot)*2.*scale;\n    #if GRADIENT_MIX == 1\n      color += step(.0,ratio)*mix(i_color1, i_color2,step(-.3, -ratio));\n      color += (1.0-step(.0, ratio))*mix(i_color2, i_color3,step(.3, -ratio));\n    #else\n      color += step(.0,ratio)*mix(i_color1, i_color2, 1.-ratio*2.);\n      color += (1.0-step(.0, ratio))*mix(i_color2, i_color3, -ratio*2.);\n    #endif\n  #elif USE_GRADIENT == 2\n    float ratio = (cos(i_gRot)*uv.y+sin(i_gRot)*uv.x)*2.*scale;\n    #if GRADIENT_MIX == 1\n      color += mix(i_color1, i_color2, step(.0, -ratio));\n    #elif GRADIENT_MIX == 2\n      float m = pow( ratio , 3);\n      color += mix(i_color1, i_color2, m);\n    #else\n      color += mix(i_color1, i_color2, .5-ratio);\n    #endif\n  #else\n    color += i_color1;\n  #endif\n    color.rgb *= step(.0, a);\n    color.a *= a;\n#if USE_FLOW_LIGHT\n  float rad = PI*i_flRot/180.;\n  float w = i_flWidth/cos(rad);\n  float tan_rad = tan(rad);\n  float t = fract(i_flTime)*(1.+w+abs(tan_rad))-w-step(.0, tan_rad)*abs(tan_rad);\n  float x = v_uv0.x-(1.-v_uv0.y)*tan_rad;\n  color.rgb = mix(color.rgb, i_flColor.rgb, step(t, x)*step(x, t+w)*(1.-smoothstep(.0, w*.5, abs(x-t-w*.5)))*i_flColor.a);\n#endif\n#if USE_SHADOW\n  vec4 sc = vec4(i_shadowColor.rgb, i_shadowColor.a*getA(vec2(uv)+i_shadowOffset));\n  color = transCol(color, sc);\n#endif\nfloat rot = PI*0.5;\nfloat sinRot=sin(rot);\nfloat cosRot=cos(rot);\nfloat p = 1.0/float(accuracy);\n#if USE_OUTLINE\n    float ola = .0;\n  #if USE_OUTLINE_SHADOW\n    float ola_shadow = .0;\n  #endif\n    vec2 tuv = uv;\n  #if USE_SHADOW\n    tuv+=i_shadowOffset/2.0;\n  #endif\n    for(int i=0;i<accuracy;i++) {\n      float rad = PI*2.*float(i)*p;\n      vec2 uv_d;\n      uv_d.x = cosRot*cos(rad)*i_outlineWidth.y-sinRot*sin(rad)*i_outlineWidth.x;\n      uv_d.y = sinRot*cos(rad)*i_outlineWidth.y+cosRot*sin(rad)*i_outlineWidth.x;\n      ola = max(ola, getA(tuv+uv_d));\n    #if USE_OUTLINE_SHADOW\n      ola_shadow = max(ola_shadow, getA(tuv+i_olShadowOffset+uv_d));\n    #endif\n    }\n    vec4 olc = vec4(i_outlineColor.rgb, i_outlineColor.a*ola);\n    color = transCol(color, olc);\n  #if USE_OUTLINE_SHADOW\n    vec4 olc_shadow = vec4(i_olShadowColor.rgb, i_olShadowColor.a*ola_shadow);\n    color = transCol(color, olc_shadow);\n  #endif\n#endif\n#if USE_GLOW\n  float ga = .0;\n  float tx = i_glowWidth.x;\n  float ty = i_glowWidth.y;\n  #if USE_OUTLINE\n  tx+=i_outlineWidth.x;\n  ty+=i_outlineWidth.y;\n  #endif\n  vec2 guv = uv;\n  #if USE_SHADOW\n      guv+=i_shadowOffset/2.0;\n  #endif\n  #if USE_GLOW == 1\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<32;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty+-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/32.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/32.;\n  #elif USE_GLOW == 2\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<16;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/16.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/16.;\n  #else\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<8;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/8.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/8.;\n  #endif\n      ga = smoothstep(.0, 1., ga*i_glowDepth);\n      vec4 gc = vec4(i_glowColor.rgb, i_glowColor.a*ga);\n      color = transCol(color, gc);\n#endif\n    color.a *= v_color.a;\n    gl_FragColor = color;\n  }"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n#endif\n  varying vec4 v_color;\n  #if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n  #endif\n#if USE_SHADOW\nuniform vec4 i_shadowColor;\nuniform vec2 i_shadowOffset;\n#endif\n#if USE_OUTLINE\nuniform vec4 i_outlineColor;\nuniform vec2 i_outlineWidth;\n  #if USE_OUTLINE_SHADOW\nuniform vec4 i_olShadowColor;\nuniform vec2 i_olShadowOffset;\n  #endif\n#endif\n#if USE_GRADIENT\nuniform vec4 i_color2;\nuniform vec4 i_color3;\nuniform float i_gRot;\n#endif\n#if USE_GLOW\n  uniform vec4 i_glowColor;\nuniform vec2 i_glowWidth;\nuniform float i_glowDepth;\n#endif\n#if USE_FLOW_LIGHT\nuniform vec4 i_flColor;\nuniform float i_flTime;\nuniform float i_flRot;\nuniform float i_flWidth;\n#endif\n  uniform vec4 i_color1;\n  const float PI = 3.1415;\n  const int accuracy = 32;\n  float getA(vec2 p) {\n  float a = 0.0001;\n#if USE_ARC\n    float r = -p.y+6.0;\n    float deg = p.x*0.7;\n    vec2 tp = vec2(\n        r*sin(deg)/4.5+0.5,\n        r*cos(deg)-5.4\n    );\n    a += texture2D(texture, tp).a;\n#else\n    vec2 tp = vec2(p.x+.5, .5-p.y);\n    a += step(abs(p.x), .5)*step(abs(p.y), .5)*texture2D(texture, tp).a;\n#endif\n    return a;\n  }\n  vec4 transCol(vec4 c1, vec4 c2) {\n    float k = (1.-c1.a)*c2.a/(c1.a+c2.a);\n    vec4 c = vec4(.0);\n    c.rgb = mix(c1.rgb, c2.rgb, k);\n    c.a = c1.a+k*c2.a;\n    return c;\n  }\n  void main () {\n    float dw = .0;\n  #if USE_SHADOW\n  dw += abs(i_shadowOffset.x);\n  #endif\n  #if USE_OUTLINE\n    dw += abs(i_outlineWidth.x*2.);\n  #if USE_OUTLINE_SHADOW\n    dw += abs(i_olShadowOffset.x);\n  #endif\n  #endif\n  #if USE_GLOW\n    dw += abs(i_glowWidth.x*2.);\n  #endif\n    float scale = 1.+dw;\n    vec2 uv = vec2(v_uv0.x-.5, .5-v_uv0.y)*scale;\n  #if USE_SHADOW\n    uv -= i_shadowOffset*0.5;\n  #endif\n  #if USE_OUTLINE\n  #if USE_OUTLINE_SHADOW\n    vec2 olsuv = vec2(i_olShadowOffset.x+sign(i_olShadowOffset.x)*i_outlineWidth.x, i_olShadowOffset.y+sign(i_olShadowOffset.y)*i_outlineWidth.y);\n    uv -= olsuv*0.5;\n  #endif\n  #endif\n  float a = getA(uv);\n  vec4 color = vec4(.0);\n  #if USE_GRADIENT == 3\n    float ratio = mix(uv.y,uv.x,i_gRot)*2.*scale;\n    #if GRADIENT_MIX == 1\n      color += step(.0,ratio)*mix(i_color1, i_color2,step(-.3, -ratio));\n      color += (1.0-step(.0, ratio))*mix(i_color2, i_color3,step(.3, -ratio));\n    #else\n      color += step(.0,ratio)*mix(i_color1, i_color2, 1.-ratio*2.);\n      color += (1.0-step(.0, ratio))*mix(i_color2, i_color3, -ratio*2.);\n    #endif\n  #elif USE_GRADIENT == 2\n    float ratio = (cos(i_gRot)*uv.y+sin(i_gRot)*uv.x)*2.*scale;\n    #if GRADIENT_MIX == 1\n      color += mix(i_color1, i_color2, step(.0, -ratio));\n    #elif GRADIENT_MIX == 2\n      float m = pow( ratio , 3);\n      color += mix(i_color1, i_color2, m);\n    #else\n      color += mix(i_color1, i_color2, .5-ratio);\n    #endif\n  #else\n    color += i_color1;\n  #endif\n    color.rgb *= step(.0, a);\n    color.a *= a;\n#if USE_FLOW_LIGHT\n  float rad = PI*i_flRot/180.;\n  float w = i_flWidth/cos(rad);\n  float tan_rad = tan(rad);\n  float t = fract(i_flTime)*(1.+w+abs(tan_rad))-w-step(.0, tan_rad)*abs(tan_rad);\n  float x = v_uv0.x-(1.-v_uv0.y)*tan_rad;\n  color.rgb = mix(color.rgb, i_flColor.rgb, step(t, x)*step(x, t+w)*(1.-smoothstep(.0, w*.5, abs(x-t-w*.5)))*i_flColor.a);\n#endif\n#if USE_SHADOW\n  vec4 sc = vec4(i_shadowColor.rgb, i_shadowColor.a*getA(vec2(uv)+i_shadowOffset));\n  color = transCol(color, sc);\n#endif\nfloat rot = PI*0.5;\nfloat sinRot=sin(rot);\nfloat cosRot=cos(rot);\nfloat p = 1.0/float(accuracy);\n#if USE_OUTLINE\n    float ola = .0;\n  #if USE_OUTLINE_SHADOW\n    float ola_shadow = .0;\n  #endif\n    vec2 tuv = uv;\n  #if USE_SHADOW\n    tuv+=i_shadowOffset/2.0;\n  #endif\n    for(int i=0;i<accuracy;i++) {\n      float rad = PI*2.*float(i)*p;\n      vec2 uv_d;\n      uv_d.x = cosRot*cos(rad)*i_outlineWidth.y-sinRot*sin(rad)*i_outlineWidth.x;\n      uv_d.y = sinRot*cos(rad)*i_outlineWidth.y+cosRot*sin(rad)*i_outlineWidth.x;\n      ola = max(ola, getA(tuv+uv_d));\n    #if USE_OUTLINE_SHADOW\n      ola_shadow = max(ola_shadow, getA(tuv+i_olShadowOffset+uv_d));\n    #endif\n    }\n    vec4 olc = vec4(i_outlineColor.rgb, i_outlineColor.a*ola);\n    color = transCol(color, olc);\n  #if USE_OUTLINE_SHADOW\n    vec4 olc_shadow = vec4(i_olShadowColor.rgb, i_olShadowColor.a*ola_shadow);\n    color = transCol(color, olc_shadow);\n  #endif\n#endif\n#if USE_GLOW\n  float ga = .0;\n  float tx = i_glowWidth.x;\n  float ty = i_glowWidth.y;\n  #if USE_OUTLINE\n  tx+=i_outlineWidth.x;\n  ty+=i_outlineWidth.y;\n  #endif\n  vec2 guv = uv;\n  #if USE_SHADOW\n      guv+=i_shadowOffset/2.0;\n  #endif\n  #if USE_GLOW == 1\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<32;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty+-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/32.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/32.;\n  #elif USE_GLOW == 2\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<16;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/16.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/16.;\n  #else\n        for(int i=0;i<accuracy;i++) {\n          float rad = PI*2.*float(i)*p;\n          for(int j=0;j<8;j++) {\n            vec2 uv_d;\n            uv_d.x = cosRot*cos(rad)*ty-sinRot*sin(rad)*tx;\n            uv_d.y = sinRot*cos(rad)*ty+cosRot*sin(rad)*tx;\n            uv_d *= float(j)/8.;\n            ga += getA(guv+uv_d);\n          }\n        }\n        ga *= p/8.;\n  #endif\n      ga = smoothstep(.0, 1., ga*i_glowDepth);\n      vec4 gc = vec4(i_glowColor.rgb, i_glowColor.a*ga);\n      color = transCol(color, gc);\n#endif\n    color.a *= v_color.a;\n    gl_FragColor = color;\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_SHADOW","type":"boolean","defines":[]},{"name":"USE_OUTLINE","type":"boolean","defines":[]},{"name":"USE_OUTLINE_SHADOW","type":"boolean","defines":["USE_OUTLINE"]},{"name":"USE_GRADIENT","type":"number","defines":[],"range":[0,3]},{"name":"USE_GLOW","type":"number","defines":[],"range":[0,3]},{"name":"USE_FLOW_LIGHT","type":"boolean","defines":[]},{"name":"USE_ARC","type":"boolean","defines":[]},{"name":"GRADIENT_MIX","type":"number","defines":["USE_GRADIENT"],"range":[0,3]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"SHADOW_ARGS","binding":1,"members":[{"name":"i_shadowColor","type":16,"count":1},{"name":"i_shadowOffset","type":14,"count":1}],"defines":["USE_SHADOW"]},{"name":"OUTLINE_ARGS","binding":2,"members":[{"name":"i_outlineColor","type":16,"count":1},{"name":"i_outlineWidth","type":14,"count":1}],"defines":["USE_OUTLINE"]},{"name":"OUTLINE_SHADOW_ARGS","binding":3,"members":[{"name":"i_olShadowColor","type":16,"count":1},{"name":"i_olShadowOffset","type":14,"count":1}],"defines":["USE_OUTLINE","USE_OUTLINE_SHADOW"]},{"name":"GRADIENT_ARGS","binding":4,"members":[{"name":"i_color2","type":16,"count":1},{"name":"i_color3","type":16,"count":1},{"name":"i_gRot","type":13,"count":1}],"defines":["USE_GRADIENT"]},{"name":"GLOW_ARGS","binding":5,"members":[{"name":"i_glowColor","type":16,"count":1},{"name":"i_glowWidth","type":14,"count":1},{"name":"i_glowDepth","type":13,"count":1}],"defines":["USE_GLOW"]},{"name":"FLOW_LIGHT_ARGS","binding":6,"members":[{"name":"i_flColor","type":16,"count":1},{"name":"i_flTime","type":13,"count":1},{"name":"i_flRot","type":13,"count":1},{"name":"i_flWidth","type":13,"count":1}],"defines":["USE_FLOW_LIGHT"]},{"name":"UARGS","binding":7,"members":[{"name":"i_color1","type":16,"count":1},{"name":"i_resolution","type":14,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"label|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"i_shadowColor":{"type":16,"value":[0,0,0,0.5]},"i_outlineColor":{"type":16,"value":[0,0,0,1]},"i_olShadowColor":{"type":16,"value":[0,0,0,0.5]},"i_color1":{"type":16,"value":[1,0,0,1]},"i_color2":{"type":16,"value":[0,1,0,1]},"i_color3":{"type":16,"value":[0,0,1,1]},"i_flColor":{"type":16,"value":[1,1,1,1]},"i_glowColor":{"type":16,"value":[1,1,1,1]},"i_resolution":{"type":14,"value":[1,1]},"i_shadowOffset":{"type":14,"value":[0.01,0.01]},"i_outlineWidth":{"type":14,"value":[0.01,0.01]},"i_olShadowOffset":{"type":14,"value":[0.01,0.01]},"i_glowWidth":{"type":14,"value":[0.1,0.1]},"i_gRot":{"type":13,"value":[0]},"i_flTime":{"type":13,"value":[0]},"i_flRot":{"type":13,"value":[0]},"i_flWidth":{"type":13,"value":[0.05]},"i_glowDepth":{"type":13,"value":[2]},"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]]]]